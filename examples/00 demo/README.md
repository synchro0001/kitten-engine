# 00 Demo

This is a simple demo that you have probably already seen in the main README. Let's walk through how you would write it.

Kitten uses a model-view-update architecture. You can read more about it online (or ask ChatGPT), but here is the gist:
- The state of your game at any point is described by a *model*. This can be as simple as a single integer (e.g. a counter) or as complex as you like. Normally, you would declare a custom `Model` type to store your game state.
- At the start of the game, an `init` function is run. This is a function that returns a `Model` and sets the initial state of the game.
- On every frame, two functions are run. `update` takes a `Model` as its argument and updates it in some way (e.g. moves the player around). After that, `view` takes in the updated `Model` as an argument and draws something to screen based on the `model`. This function should return nothing, so kitten explicitly demands that it return a `Nil`. After that, a new frame is generated by running `update` again on the new `Model`, and then `view` again, and so on and so forth.
- You do not need to call the `init`, `update` or `view` functions explicitly; simply pass them into the engine-starting function in the `canvas` module, and it will call them for you.

With Gleam being functional and very strict with its types, kitten cannot really run much "magic behind scenes" to make your game work. You will need to write your game logic yourself; think of kitten not as a program that you attach yourself to, but as a collection of tools to make your own program.

With that out of the way, we can finally write some code. I highly recommend that you start writing your game by modelling its state with your `Model` type. In the case of this demo, the only information that we want to preserve between frames is the player's position, so that's all we include in the model.

```gleam
import kitten/vec2.{type Vec2, Vec2}

type Model {
  Model(player_pos: Vec2)
}
```

While we're at it, let's also define a few constants: 
```gleam
const player_velocity = 5.0

const player_size = Vec2(80.0, 80.0)
```

At the start of the game, we want the player to be at the centre of the screen.

```gleam
fn init() {
  Model(player_pos: Vec2(0.0, 0.0))
}
```

And since we already know what our model looks like, we can write a `view` function for it. Every `view` function should start with a call to `draw.context()` (which provides a canvas 2D context) and chain functions from the `draw` module onto that. See the documentation for the `draw` module for more details.

```gleam 
import kitten/color
import kitten/draw

// ...

fn view(model: Model) {
  draw.context()
  |> draw.background(color.black)
  |> draw.rect(model.player_pos, player_size, color.red)
  Nil
}
```

To check that what we've written so far works, we can a write a placeholder for our `update` function that does nothing and simply returns the same model, and then start the engine. Note that in order to start the canvas, we specify its size in world coordinates. 1920x1080 is a common monitor resolution; although a browser window will be slightly smaller, this is a good enough approximation for 1 unit of world space being 1 pixel.

```gleam
pub fn main() {
  canvas.start_window(init, update, view, "canvas", 1920.0, 1080.0, [], [])
}

fn update(model: Model) {
  model
}
```

Don't worry about the empty lists at the end of the `start_window` function; we'll get to those later. 

At this point, if you build your code and open the HTML file, you should see a small red square at the centre of the screen. All that's left to do is to make it move.

To do this, we need the `key` module, which helps us take keyboard input. In the `update` function, we can define the new player position as follows to react to the "W" key being pressed (yes, you absolutely can use case statements in function pipes).

```gleam
import kitten/key

// ...

fn update(model: Model) {
  let new_player_pos =
    model.player_pos
    |> case key.is_down(key.W) {
      True -> vec2.add(_, Vec2(0.0, player_velocity))
      _ -> vec2.id
    }
  Model(player_pos: new_player_pos)
}
```

This code essentially says that if the "W" key is down, we increase the vertical component of the player's position by the `player_velocity`, and if not, we keep it the same. We can do the same for the other three keys ("A", "S" and "D"): 

```gleam
fn update(model: Model) {
  let new_player_pos =
    model.player_pos
    |> case key.is_down(key.W) {
      True -> vec2.add(_, Vec2(0.0, player_velocity))
      _ -> vec2.id
    }
    |> case key.is_down(key.S) {
      True -> vec2.subtract(_, Vec2(0.0, player_velocity))
      _ -> vec2.id
    }
    |> case key.is_down(key.D) {
      True -> vec2.add(_, Vec2(player_velocity, 0.0))
      _ -> vec2.id
    }
    |> case key.is_down(key.A) {
      True -> vec2.subtract(_, Vec2(player_velocity, 0.0))
      _ -> vec2.id
    }
  Model(player_pos: new_player_pos)
}
```

And that's it, that's the "game" done. Feel free to play around with it or move on to the next example.

*Bonus*: At the moment, the player moves faster diagonally than horizontally or vertically. That's because we're incrementing both the horizontal and vertical component of `player_pos` on each frame. How could you make sure that the player moves at the same velocity in any direction? 

*Hint*: Look through the utility functions in the `vec2` module.